{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/articles/2015-09/1의-보수","webpackCompilationHash":"8aeaabf65ab5b4d6a17f","result":{"data":{"site":{"siteMetadata":{"title":"GyeongSu Han's Github Pages","author":"@micalgenus","siteUrl":"https://micalgenus.github.io"}},"markdownRemark":{"id":"7874fa24-9893-5d08-8e07-a9e326a7f57f","html":"<p><a href=\"/articles/2015-09/sign-magnitude\">sign-magnitude</a>를 보완하기 위해서 나온게 1의 보수이다.</p>\n<p>1의 보수는 현재 사용하고 있는 2의 보수와 비슷하다.</p>\n<p>이론은 간단하다. bit를 뒤집는것이 1의 보수의 원리이다.</p>\n<p>예를 들어 표현하겠다. 4bit환경에 3과 -3이 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 3: 0 0 1 1\n-3: 1 1 0 0</code></pre></div>\n<p>이렇게 서로 반대되는 bit구성을 가지게 된다. 1의 보수에도 문제가 존재했다.</p>\n<p>sign and magnitude의 큰 문제점인 덧셈과 비교에 관한부분은 해결이 되었다. 하지만 0은 역시 2개가 존재하게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 0: 0 0 0 0\n-0: 1 1 1</code></pre></div>\n<p>이렇게 0이 2개가 존재하게 되는데, 컴퓨터에서 -0은 의미가 없으므로 <strong>낭비</strong>가 되는 숫자이다.</p>","frontmatter":{"categories":["Computer Structure"],"title":"1의 보수","date":"Sep 19, 2015","tags":["CS"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"comments":true,"previous":{"frontmatter":{"path":"/articles/2015-09/2의-보수","title":"2의 보수","comments":true}},"next":{"frontmatter":{"path":"/articles/2015-09/likely-unlikely","title":"likely / unlikely","comments":true}}}}}