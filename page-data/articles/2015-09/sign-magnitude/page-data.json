{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/articles/2015-09/sign-magnitude","result":{"data":{"site":{"siteMetadata":{"title":"GyeongSu Han's Github Pages","author":"@micalgenus","siteUrl":"https://micalgenus.github.io"}},"markdownRemark":{"id":"1dce2c08-ce29-5542-a616-1d6be5e6bd7c","html":"<p>sign-magnitude는 전체 bit중에 <strong>최상위 bit</strong>의 값을 이용하여 부호를 판별하는 방법이다.</p>\n<p>이 방법을 이용하면 기존에 양의 정수밖에 표현할 수 밖에 없던 값을 <strong>음수</strong>도 표현할 수 있도록 도와준다.</p>\n<p>4bit의 환경을 예를 들겠다.</p>\n<p>4bit로된 3과 -3이라는 값이 있다. 이는 bit로 표현하면</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> 3: 0 0 1 1\n-3: 1 0 1 1</code></pre></div>\n<p>이 둘의 차이를 보면 맨앞인 최상위 bit만 다르다는 점이다.</p>\n<p>이 방식에는 단점이 존재한다. 가장 큰 문제점은 음수가 작아지면(절대값은 커지면) bit값은 커지게 되는데, 이를 예를 들어 알아보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-0: 1 0 0 0\n-1: 1 0 0 1\n-2: 1 0 1 0\n-3: 1 0 1 1\n-4: 1 1 0 0\n-5: 1 1 0 1\n-6: 1 1 1 0\n-7: 1 1 1 1</code></pre></div>\n<p><code class=\"language-text\">음수</code>의 값은 점점 작아지는데, bit로 보게되면 값은 <strong>점점 커지게</strong> 된다. 이와 반대로 양수의 경우를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">0: 0 0 0 0\n1: 0 0 0 1\n2: 0 0 1 0\n3: 0 0 1 1\n4: 0 1 0 0\n5: 0 1 0 1\n6: 0 1 1 0\n7: 0 1 1 1</code></pre></div>\n<p><code class=\"language-text\">양수</code>는 값이 커지면 bit로 보아도 <strong>값이 커지게</strong> 된다.</p>\n<p>가장 큰 문제점은 양수와 음수의 계산에서 발생한다.</p>\n<p>3과 -3을 더하게 될 경우 0이 나와야 하는데, 실제로 계산을 해보게 되면 그러한 결과가 나오지 않게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   3 |   0 0 1 1\n+ -3 | + 1 0 1 1\n-----|----------\n  -6 |   1 1 1 0</code></pre></div>\n<p>3과 -3을 더했는데 실제 비트를 비교해 보면 -6이 나오게 된다.</p>\n<p>이 때문에 음수와 양수의 계산에서 새롭게 정의를 해주어야 한다.</p>\n<p>두번째 문제점이 되는 이유는, 비교연산과 같은 부분에서 발생한다. 비교연산을 하게되면, 양수끼리 비교를 하게될 경우 bit로 보아서 큰값이 큰 값이 된다.</p>\n<p>하지만, <code class=\"language-text\">음수</code>의 경우 bit가 클 경우 실제 값은 더 작은 경우가 된다. 이 때 비교연산하는 부분을 <strong>따로 정의</strong>를 해주어야 하므로 낭비가 발생한다.</p>\n<p>마지막 문제점은 0과 -0이 동시에 존재하는 점이다. bit로는 다른 <code class=\"language-text\">0000</code>과 <code class=\"language-text\">1000</code>이지만 실제 값은 같은 0을 가르키고 있으므로 <strong>낭비</strong>가 생기게 된다.</p>","frontmatter":{"categories":["Computer Structure"],"title":"sign-magnitude","date":"Sep 19, 2015","tags":["CS"]}}},"pageContext":{"comments":true,"previous":{"frontmatter":{"path":"/articles/2015-09/likely-unlikely","title":"likely / unlikely","comments":true}},"next":{"frontmatter":{"path":"/articles/2015-10/FTZ-Level5","title":"FTZ Level5","comments":true}}}}}