{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/articles/2015-05/Confidence-CTF-Teaser-2015-So-easy-100-(reverse)","webpackCompilationHash":"8aeaabf65ab5b4d6a17f","result":{"data":{"site":{"siteMetadata":{"title":"GyeongSu Han's Github Pages","author":"@micalgenus","siteUrl":"https://micalgenus.github.io"}},"markdownRemark":{"id":"663dd890-a2a0-567c-8b50-93817fd56dd4","html":"<p>문제 파일 및 정확한 write-up을 <a href=\"https://github.com/ctfs/write-ups-2015/tree/master/confidence-ctf-teaser-2015/reverse/so-easy-100\">참고</a>해주세요.</p>\n<p>우선 이 문제를 받고 어떠한 파일인지 확인을 해보았습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@ubuntu:~<span class=\"token comment\"># ls -l re_100_final</span>\n-rwxr-xr-x <span class=\"token number\">1</span> root root <span class=\"token number\">9756</span> <span class=\"token number\">2015</span>-04-24 <span class=\"token number\">21</span>:10 re_100_final\nroot@ubuntu:~<span class=\"token comment\"># file re_100_final</span>\nre_100_final: ELF <span class=\"token number\">32</span>-bit LSB executable, Intel <span class=\"token number\">80386</span>, version <span class=\"token number\">1</span> <span class=\"token punctuation\">(</span>SYSV<span class=\"token punctuation\">)</span>, dynamically linked <span class=\"token punctuation\">(</span>uses shared libs<span class=\"token punctuation\">)</span>, <span class=\"token keyword\">for</span> GNU/Linux <span class=\"token number\">2.6</span>.24, stripped</code></pre></div>\n<p>문제 파일을 보게되면 <code class=\"language-text\">32bit</code> 리눅스 Intel계열 에서 실행이 가능합니다.</p>\n<p>이제 실행을 해보도록 하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@ubuntu:~<span class=\"token comment\"># ./re_100_final</span>\nPlease enter secret flag:\n<span class=\"token number\">1234</span>\nNope<span class=\"token operator\">!</span></code></pre></div>\n<p>1234를 입력해 보았는데, 이렇게 뜹니다. 그럼 오버플로우를 일으켜 보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@ubuntu:~<span class=\"token comment\"># (python -c 'print \"A\"\\*10000';cat) | ./re_100_final</span>\nPlease enter secret flag:\nNope<span class=\"token operator\">!</span>\nclose failed <span class=\"token keyword\">in</span> <span class=\"token function\">file</span> object destructor\nError <span class=\"token keyword\">in</span> sys.excepthook:\n\nOriginal excetion was:</code></pre></div>\n<p>Segment fault가 뜨지 않고 종료가 되었습니다. 그럼 BOF는 통하지 않는듯 합니다.</p>\n<p>(지금 생각해보면 reversing문제인데 BOF를 시도한게 잘못된 생각같네요 ㅎㅎ..)</p>\n<p>이렇게 막힐때는 파일을 뜯어보아야 할 것 같습니다. IDA를 이용하여 파일을 열어보도록 하겠습니다.</p>\n<p><img src=\"/img/2015-05/Confidence-CTF-Teaser-2015-So-easy-100-reverse/img1.png\" alt=\"img1\"></p>\n<p>_puts를 call하는데 출력하는 문자열이 <code class=\"language-text\">Please enter secret flag:</code> 인것을 보아 이 부분이 시작되는 부분이 아닐까 생각되었습니다.</p>\n<p>그래서 이 함수를 분석해 보았습니다. 시작 부분에서 출력을 한 후, scanf를 이용하여 <code class=\"language-text\">%31s</code> 서식문자를 통해 입력을 받습니다. 이 서식문자를 통하여 입력 글자수를 제한하고 있네요.</p>\n<p>그럼 조금 더 아랫부분을 살펴보도록 하겠습니다.</p>\n<p><img src=\"/img/2015-05/Confidence-CTF-Teaser-2015-So-easy-100-reverse/img2.png\" alt=\"img2\"></p>\n<p>여기서 왼쪽 <code class=\"language-text\">mov dword ptr [esp], offset s1</code> 부분을 보게되면 <code class=\"language-text\">dRGNs{tHISwASsOsIMPLE}</code>이라는 문자열과, s2에 저장된 문자열을 strcmp를 이용하여 비교하는 부분을 볼 수 있습니다.</p>\n<p>strcmp를 이용하여 비교하는 부분을 보고, 해당 문자열을 직접 입력해 보았습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@ubuntu:~<span class=\"token comment\"># ./re_100_final</span>\nPlease enter secret flag:\ndRGNs<span class=\"token punctuation\">{</span>tHISwASsOsIMPLE<span class=\"token punctuation\">}</span>\nNope<span class=\"token operator\">!</span></code></pre></div>\n<p>하지만 역시 이렇게 쉬운 문제일 이유가 없습니다. 답이 아니므로, 이후 부분을 분석해 보도록 하겠습니다.</p>\n<p>우선 처음 부분이 끝나고 scanf리턴값과 1을 비교하여 값이 같을 경우 다음과 같은 부분이 실행되게 됩니다.</p>\n<p>만약 1이 아니면 무엇일까 따라가 보았습니다.</p>\n<p><img src=\"/img/2015-05/Confidence-CTF-Teaser-2015-So-easy-100-reverse/img3.png\" alt=\"img3\"></p>\n<p>이렇게 <code class=\"language-text\">leave retn</code>을 하여 함수를 종료하게 되었습니다.</p>\n<p>scanf의 리턴값이 1이라는 뜻은 정상적인 입력을 처리하였다는 뜻으로 알고 있는데, 이 뜻이 맞다고 생각해보면 정상적인 입력을 처리하였을 때 빨간색 선을 따라서 진행한다고 볼 수 있습니다.</p>\n<p>빨간 선을 따라가 보면</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mov    dword ptr [esp+14h], offset s2\njmp    short loc_8048ABE</code></pre></div>\n<p>이 명령을 실행하게 됩니다. s2에 있는 값을 <code class=\"language-text\">[esp+14h]</code>에 저장합니다. 이후 <strong>loc_8048ABE</strong>로 점프를 합니다.</p>\n<p>여기서 방금 저장한 <code class=\"language-text\">[esp+14h]</code>에 있는 값을 eax에 저장을 하고, <code class=\"language-text\">byte ptr [eax]</code>를 통하여 포인터 연산을 통하여 값에 접근합니다.</p>\n<p>그렇게 접근한 값을 이용하여</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">test    al, al\njnz    short loc_8048A67</code></pre></div>\n<p>명령을 실행하게 됩니다.</p>\n<p>이 명령을 통하여 eax에 있는 값이 0인지를 판별하게 됩니다. 만약 0이게 될 경우 왼쪽을, 0이 아닐 경우 오른쪽 명령을 실행하게 됩니다.</p>\n<p>오른쪽을 알아보기 전에 디버깅을 통하여 <code class=\"language-text\">dRGNs{tHISwASsOsIMPLE}</code>이 안되는데 그 부분을 따라 가도록 하겠습니다.</p>\n<p><img src=\"/img/2015-05/Confidence-CTF-Teaser-2015-So-easy-100-reverse/img4.png\" alt=\"img4\"></p>\n<p>strcmp를 실행하기 직전의 상황으로 s1의 데이터가 <code class=\"language-text\">dRGNs{tHISwASsOsIMPLE}</code>의 문자열이 저장된 공간이고, s2가 사용자로부터 입력받은 데이터 입니다.</p>\n<p>왼쪽 화면에서 체크가 되어있는 부분이 사용자로 입력을 받은 부분이 되겠습니다.</p>\n<p><code class=\"language-text\">dRGNs{tHISwASsOsIMPLE}</code> 로 입력하게 되었지만 실제 데이터 상에는 <code class=\"language-text\">DrgnS{ThisWasSoSimple}</code>이라는 문자열이 저장되어 있습니다.</p>\n<p>자세히 살펴보면 소문자는 대문자로 바뀌게 되었고, 대문자는 소문자로 바뀌게 되었습니다.</p>\n<p>그럼 이 특성을 이용하여 <code class=\"language-text\">DrgnS{ThisWasSoSimple}</code>을 입력해 보도록 하겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@ubuntu:~<span class=\"token comment\"># ./re_100_final</span>\nPlease enter secret flag:\nDrgnS<span class=\"token punctuation\">{</span>ThisWasSoSimple<span class=\"token punctuation\">}</span>\nNope<span class=\"token operator\">!</span></code></pre></div>\n<p>아직도 정답이 아니라고 나오네요. 그럼 오른쪽 부분을 마저 해석해 보았습니다.</p>\n<p>해석해 보았을때, 소문자를 대문자로, 대문자를 소문자로 바꾸는 명령이 전부였습니다.</p>\n<p><img src=\"/img/2015-05/Confidence-CTF-Teaser-2015-So-easy-100-reverse/img5.png\" alt=\"img5\"></p>\n<p>그래서 한 구간씩 검사를 하게 되었는데, printf함수를 지난 후에도 출력이 되지 않았습니다. 뭔가 이상함을 느끼고 출력을 하는 부분까지 스텝을 넘겨 보았습니다.</p>\n<p><img src=\"/img/2015-05/Confidence-CTF-Teaser-2015-So-easy-100-reverse/img6.png\" alt=\"img6\"></p>\n<p>이렇게 putchar 함수를 이용하여 출력을 하게 되었습니다.</p>\n<p>우선 printf함수를 지나가게 되어도 출력이 되지 않았다는 점을 생각하여 <code class=\"language-text\">putchar</code> 함수 주변에서 어떤 행위를 하지 않을까 생각을 가지게 되었습니다.</p>\n<p>putchar 함수를 사용하여 출력하는 부분이 어떠한 함수에 속하는지 살펴 보았는데,</p>\n<p><img src=\"/img/2015-05/Confidence-CTF-Teaser-2015-So-easy-100-reverse/img7.png\" alt=\"img7\"></p>\n<p>왼쪽으로 갈 경우 <code class=\"language-text\">Excellent Work!</code>를 출력하고, 오른쪽으로 갈 경우 <code class=\"language-text\">Nope!</code>를 출력하게 됩니다.</p>\n<p>그럼 이 부분을 거치게 되어 왼쪽으로 갈 조건을 만족하게 되면 해결을 할 가능성이 있다고 생각됩니다.</p>\n<p>그럼 위에 조건을 판별하겠습니다.</p>\n<p><img src=\"/img/2015-05/Confidence-CTF-Teaser-2015-So-easy-100-reverse/img8.png\" alt=\"img8\"></p>\n<p>생각했던것 보다 짧네요. 마지막 <code class=\"language-text\">loc_8048795:</code> 이 부분을 기점으로 마지막 출력을 하게 됩니다. 그러면 이 부분에서 cmp를 사용하는 [ebp+var_15]의 값을 추적해 가면서 진행을 하여야 할 것 같습니다. <code class=\"language-text\">loc_8048795:</code>의 왼쪽 위에 있는 부분을 보게되면,</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mov    [ebp+var_15], 0</code></pre></div>\n<p>을 사용하여 <code class=\"language-text\">[ebp+var_15]</code>에 값을 0을 넣어 줍니다. 마지막 cmp부분에서 <code class=\"language-text\">[ebp+var_15]</code>와 0을 cmp하게 되는데, 왼쪽위에 있는 부분을 지나게 될 경우 <code class=\"language-text\">[ebp+var_15]</code>의 값이 0이 되므로 jz는 참이 되게 됩니다.</p>\n<p>그러므로 오른쪽인 <code class=\"language-text\">Nope!</code>을 출력하게 됩니다. 그러면 왼쪽을 지나가지 않도록 만들어야 되겠습니다.</p>\n<p>왼쪽이 지나가지 않으려면 <code class=\"language-text\">loc_804875F:</code>의 마지막에 jz가 <strong>모두 참</strong>이여야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">jz    short loc_804878B</code></pre></div>\n<p>이 부분이 항상 참 이여야 하므로, test al, al의 zf가 1이 되어야 합니다.</p>\n<p><code class=\"language-text\">test</code>는 AND연산을 하게 되는데, 같은 값을 AND하게 되므로 al의 값이 0이여야 <code class=\"language-text\">zf가 1</code>이 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">setnz al</code></pre></div>\n<p>이 부분의 결과값에 의하여 test의 결과가 결정되는데, 이 명령은 zf가 1이면 al에 0을, zf가 0이면 al에 1을 주게 됩니다. 그러므로 <code class=\"language-text\">al</code>의 값이 <code class=\"language-text\">0</code>이 되어야 jz가 만족합니다.</p>\n<p>zf를 결정하기 위해서는 cmp를 수행해야 하는데, <code class=\"language-text\">edx</code>와 <code class=\"language-text\">eax</code>의 값을 비교하게 됩니다. 두 값이 같게되면 zf는 1, 다르면 zf는 0을 가지게 됩니다.</p>\n<p>그럼 break point를 cmp부분에 주고 값을 비교해 보겠습니다.</p>\n<p><img src=\"/img/2015-05/Confidence-CTF-Teaser-2015-So-easy-100-reverse/img9.png\" alt=\"img9\"></p>\n<p>이러한 순서로 값을 비교하면 됩니다. ecx(문자 위치)에 따라서, <code class=\"language-text\">0x64(d)</code>, <code class=\"language-text\">0x52(R)</code>, <code class=\"language-text\">0x47(G)</code>, <code class=\"language-text\">0x4e(N)</code>, <code class=\"language-text\">0x73(s)</code>, <code class=\"language-text\">0x7b({)</code>까지는 일치하게 됩니다.</p>\n<p>하지만 ecx가 6일때는 값이 다르게 됩니다. <code class=\"language-text\">0x74(t)</code>와 <code class=\"language-text\">0x6e(n)</code>이 일치하지 않습니다. 앞의 문자를 보게되면 입력하게된 값임을 추측할 수 있습니다. 그리고 eax에 들어간 값은 입력된 값인 t를 나타내고 있습니다.</p>\n<p>그럼 t를 n으로 바꾸고 해주어야 합니다.</p>\n<p><img src=\"/img/2015-05/Confidence-CTF-Teaser-2015-So-easy-100-reverse/img10.png\" alt=\"img10\"></p>\n<p>n으로 입력을 해주게 되었는데, 값이 <code class=\"language-text\">0x74</code>에서 <code class=\"language-text\">0x4e</code>로 바뀌게 되었습니다. 이로써 입력한 값으로 변경됨을 알았습니다.</p>\n<p>하지만 <code class=\"language-text\">0x6e(n)</code>을 입력하였는데 <code class=\"language-text\">0x4e(N)</code>이 입력되었습니다. 이는 처음 분석하였던 부분인 대소문자를 변경해주는 부분에 의해서 변경이 이루어지게 됩니다.</p>\n<p>그러므로 입력된 값을 대소문자를 변경해 주어서 입력해야 됩니다.</p>\n<p>이러한 방법으로 한문자씩 변경을 해주게 되면 최종적인 값을 추출할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">root@ubuntu:~<span class=\"token comment\"># ./re_100_final</span>\nPlease enter secret flag:\nDrgnS<span class=\"token punctuation\">{</span>NotEvenWarmedUp<span class=\"token punctuation\">}</span>\nExcellent Work<span class=\"token operator\">!</span></code></pre></div>","frontmatter":{"categories":["CTF"],"title":"Confidence CTF Teaser 2015 - So easy[100] (reverse)","date":"May 13, 2015","tags":["Confidence CTF Teaser 2015","Reversing"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"comments":true,"previous":null,"next":{"frontmatter":{"path":"/articles/2015-05/FTZ-level1","title":"FTZ Level1","comments":true}}}}}